//------------------------------------------------------------------------------
// <auto-generated>
// This code was generated by a tool
// Runtime Version: 1.0.0.0
//
// Changes to this file may cause incorrect behavior and will be lost if
// the code is regenerated
// </auto-generated>
//------------------------------------------------------------------------------
#nullable enable

using System;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace HellEngine.Mathematics;

/// <summary>Vector containing two float values</summary>
[Serializable]
[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct float2 : IEquatable<float2>, IFormattable {
    #region Members

    /// <summary>x Vector component</summary>
    public float x;

    /// <summary>y Vector component</summary>
    public float y;

    #endregion Members

    #region Index Accessor

    /// <summary>Access the float at index</summary>
    public float this[int index] {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get {
#if VALIDATION_CHECKS
            if (index >= 2) {
                throw new IndexOutOfRangeException("Index must be between [0..1]");
            }
#endif
            fixed (float2* array = &this) { return ((float*)array)[index]; }
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set {
#if VALIDATION_CHECKS
            if (index >= 2) {
                throw new IndexOutOfRangeException("Index must be between [0..1]");
            }
#endif
            fixed (float* array = &x) { array[index] = value; }
        }
    }

    #endregion Index Accessor

    #region Static Fields

    /// <summary>float2 zero value</summary>
    public static readonly float2 zero = new float2(0f, 0f);

    /// <summary>float2 one value</summary>
    public static readonly float2 one = new float2(1f, 1f);

    /// <summary>float2 unit x value</summary>
    public static readonly float2 unitX = new float2(1f, 0f);

    /// <summary>float2 unit y value</summary>
    public static readonly float2 unitY = new float2(0f, 1f);

    #endregion Static Fields

    #region Constructors

    /// <summary>Creates a new float2</summary>
    /// <param name="x">Value of x component</param>
    /// <param name="y">Value of y component</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public float2(float x, float y) {
        this.x = x;
        this.y = y;
    }

    /// <summary>Creates a new float2</summary>
    /// <param name="xy">Value of xy components</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public float2(float2 xy) {
        this.x = xy.x;
        this.y = xy.y;
    }

    #endregion Constructors

    #region Conversion

    /// <summary>Creates a float2 vector from a float value</summary>
    /// <param name="v">Component values. Converted if necessary</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public float2(float v) {
        this.x = v;
        this.y = v;
    }

    /// <summary>Creates a float2 vector from a bool value</summary>
    /// <param name="v">Component values. Converted if necessary</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public float2(bool v) {
        this.x = v ? 1f : 0f;
        this.y = v ? 1f : 0f;
    }

    /// <summary>Creates a float2 vector from a bool2 vector</summary>
    /// <param name="v">Component values. Converted if necessary</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public float2(bool2 v) {
        this.x = v.x ? 1f : 0f;
        this.y = v.y ? 1f : 0f;
    }

    /// <summary>Creates a float2 vector from an int value</summary>
    /// <param name="v">Component values. Converted if necessary</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public float2(int v) {
        this.x = (float)v;
        this.y = (float)v;
    }

    /// <summary>Creates a float2 vector from an int2 vector</summary>
    /// <param name="v">Component values. Converted if necessary</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public float2(int2 v) {
        this.x = (float)v.x;
        this.y = (float)v.y;
    }

    /// <summary>Creates a float2 vector from an uint value</summary>
    /// <param name="v">Component values. Converted if necessary</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public float2(uint v) {
        this.x = (float)v;
        this.y = (float)v;
    }

    /// <summary>Creates a float2 vector from a double value</summary>
    /// <param name="v">Component values. Converted if necessary</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public float2(double v) {
        this.x = (float)v;
        this.y = (float)v;
    }

    /// <summary>Converts a float value to a float2 vector</summary>
    /// <param name="v">Value to convert</param>
    /// <returns>Converted value</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static implicit operator float2(float v) => new float2(v);

    /// <summary>Converts a bool value to a float2 vector</summary>
    /// <param name="v">Value to convert</param>
    /// <returns>Converted value</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator float2(bool v) => new float2(v);

    /// <summary>Converts a bool2 vector to a float2 vector</summary>
    /// <param name="v">Value to convert</param>
    /// <returns>Converted value</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator float2(bool2 v) => new float2(v);

    /// <summary>Converts an int value to a float2 vector</summary>
    /// <param name="v">Value to convert</param>
    /// <returns>Converted value</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator float2(int v) => new float2(v);

    /// <summary>Converts an int2 vector to a float2 vector</summary>
    /// <param name="v">Value to convert</param>
    /// <returns>Converted value</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator float2(int2 v) => new float2(v);

    /// <summary>Converts an uint value to a float2 vector</summary>
    /// <param name="v">Value to convert</param>
    /// <returns>Converted value</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator float2(uint v) => new float2(v);

    /// <summary>Converts a double value to a float2 vector</summary>
    /// <param name="v">Value to convert</param>
    /// <returns>Converted value</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator float2(double v) => new float2(v);

    #endregion Conversion

    #region Operators

    /// <summary>Componentwise addition operation on two float2 vectors</summary>
    /// <param name="left">Left hand side float2 vector for addition</param>
    /// <param name="right">Right hand side float2 vector for addition</param>
    /// <returns>Componentwise addition result</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 operator +(in float2 left, in float2 right) {
        return new float2(left.x + right.x, left.y + right.y);
    }

    /// <summary>Componentwise addition operation on a float2 vector and a float value</summary>
    /// <param name="left">Left hand side float2 vector for addition</param>
    /// <param name="right">Right hand side float value for addition</param>
    /// <returns>Componentwise addition result</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 operator +(in float2 left, in float right) {
        return new float2(left.x + right, left.y + right);
    }

    /// <summary>Componentwise addition operation on a float value and a float2 vector</summary>
    /// <param name="left">Left hand side float value for addition</param>
    /// <param name="right">Right hand side float2 vector for addition</param>
    /// <returns>Componentwise addition result</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 operator +(in float left, in float2 right) {
        return new float2(left + right.x, left + right.y);
    }

    /// <summary>Componentwise subtraction operation on two float2 vectors</summary>
    /// <param name="left">Left hand side float2 vector for subtraction</param>
    /// <param name="right">Right hand side float2 vector for subtraction</param>
    /// <returns>Componentwise subtraction result</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 operator -(in float2 left, in float2 right) {
        return new float2(left.x - right.x, left.y - right.y);
    }

    /// <summary>Componentwise subtraction operation on a float2 vector and a float value</summary>
    /// <param name="left">Left hand side float2 vector for subtraction</param>
    /// <param name="right">Right hand side float value for subtraction</param>
    /// <returns>Componentwise subtraction result</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 operator -(in float2 left, in float right) {
        return new float2(left.x - right, left.y - right);
    }

    /// <summary>Componentwise subtraction operation on a float value and a float2 vector</summary>
    /// <param name="left">Left hand side float value for subtraction</param>
    /// <param name="right">Right hand side float2 vector for subtraction</param>
    /// <returns>Componentwise subtraction result</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 operator -(in float left, in float2 right) {
        return new float2(left - right.x, left - right.y);
    }

    /// <summary>Componentwise multiplication operation on two float2 vectors</summary>
    /// <param name="left">Left hand side float2 vector for multiplication</param>
    /// <param name="right">Right hand side float2 vector for multiplication</param>
    /// <returns>Componentwise multiplication result</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 operator *(in float2 left, in float2 right) {
        return new float2(left.x * right.x, left.y * right.y);
    }

    /// <summary>Componentwise multiplication operation on a float2 vector and a float value</summary>
    /// <param name="left">Left hand side float2 vector for multiplication</param>
    /// <param name="right">Right hand side float value for multiplication</param>
    /// <returns>Componentwise multiplication result</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 operator *(in float2 left, in float right) {
        return new float2(left.x * right, left.y * right);
    }

    /// <summary>Componentwise multiplication operation on a float value and a float2 vector</summary>
    /// <param name="left">Left hand side float value for multiplication</param>
    /// <param name="right">Right hand side float2 vector for multiplication</param>
    /// <returns>Componentwise multiplication result</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 operator *(in float left, in float2 right) {
        return new float2(left * right.x, left * right.y);
    }

    /// <summary>Componentwise division operation on two float2 vectors</summary>
    /// <param name="left">Left hand side float2 vector for division</param>
    /// <param name="right">Right hand side float2 vector for division</param>
    /// <returns>Componentwise division result</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 operator /(in float2 left, in float2 right) {
        return new float2(left.x / right.x, left.y / right.y);
    }

    /// <summary>Componentwise division operation on a float2 vector and a float value</summary>
    /// <param name="left">Left hand side float2 vector for division</param>
    /// <param name="right">Right hand side float value for division</param>
    /// <returns>Componentwise division result</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 operator /(in float2 left, in float right) {
        return new float2(left.x / right, left.y / right);
    }

    /// <summary>Componentwise division operation on a float value and a float2 vector</summary>
    /// <param name="left">Left hand side float value for division</param>
    /// <param name="right">Right hand side float2 vector for division</param>
    /// <returns>Componentwise division result</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 operator /(in float left, in float2 right) {
        return new float2(left / right.x, left / right.y);
    }

    /// <summary>Componentwise remainder operation on two float2 vectors</summary>
    /// <param name="left">Left hand side float2 vector for remainder</param>
    /// <param name="right">Right hand side float2 vector for remainder</param>
    /// <returns>Componentwise remainder result</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 operator %(in float2 left, in float2 right) {
        return new float2(left.x % right.x, left.y % right.y);
    }

    /// <summary>Componentwise remainder operation on a float2 vector and a float value</summary>
    /// <param name="left">Left hand side float2 vector for remainder</param>
    /// <param name="right">Right hand side float value for remainder</param>
    /// <returns>Componentwise remainder result</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 operator %(in float2 left, in float right) {
        return new float2(left.x % right, left.y % right);
    }

    /// <summary>Componentwise remainder operation on a float value and a float2 vector</summary>
    /// <param name="left">Left hand side float value for remainder</param>
    /// <param name="right">Right hand side float2 vector for remainder</param>
    /// <returns>Componentwise remainder result</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 operator %(in float left, in float2 right) {
        return new float2(left % right.x, left % right.y);
    }

    /// <summary>Componentwise increment operation on a float2 vector</summary>
    /// <param name="value">Value for componentwise increment</param>
    /// <returns>Componentwise increment float2 result</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 operator ++(float2 value) {
        return new float2(++value.x, ++value.y);
    }

    /// <summary>Componentwise decrement operation on a float2 vector</summary>
    /// <param name="value">Value for componentwise decrement</param>
    /// <returns>Componentwise decrement float2 result</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 operator --(float2 value) {
        return new float2(--value.x, --value.y);
    }

    /// <summary>Componentwise unary minus operation on a float2 vector</summary>
    /// <param name="value">Value for componentwise unary minus</param>
    /// <returns>Componentwise unary minus float2 result</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 operator -(float2 value) {
        return new float2(-value.x, -value.y);
    }

    /// <summary>Componentwise unary plus operation on a float2 vector</summary>
    /// <param name="value">Value for componentwise unary plus</param>
    /// <returns>Componentwise unary plus float2 result</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 operator +(float2 value) {
        return new float2(+value.x, +value.y);
    }

    /// <summary>Componentwise less than operation on two float2 vectors</summary>
    /// <param name="left">Left hand side float2 vector for less than</param>
    /// <param name="right">Right hand side float2 vector for less than</param>
    /// <returns>Componentwise less than result</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool2 operator <(in float2 left, in float2 right) {
        return new bool2(left.x < right.x, left.y < right.y);
    }

    /// <summary>Componentwise less than operation on a float2 vector and a float value</summary>
    /// <param name="left">Left hand side float2 vector for less than</param>
    /// <param name="right">Right hand side float value for less than</param>
    /// <returns>Componentwise less than result</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool2 operator <(in float2 left, in float right) {
        return new bool2(left.x < right, left.y < right);
    }

    /// <summary>Componentwise less than operation on a float value and a float2 vector</summary>
    /// <param name="left">Left hand side float value for less than</param>
    /// <param name="right">Right hand side float2 vector for less than</param>
    /// <returns>Componentwise less than result</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool2 operator <(in float left, in float2 right) {
        return new bool2(left < right.x, left < right.y);
    }

    /// <summary>Componentwise less than or equal operation on two float2 vectors</summary>
    /// <param name="left">Left hand side float2 vector for less than or equal</param>
    /// <param name="right">Right hand side float2 vector for less than or equal</param>
    /// <returns>Componentwise less than or equal result</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool2 operator <=(in float2 left, in float2 right) {
        return new bool2(left.x <= right.x, left.y <= right.y);
    }

    /// <summary>Componentwise less than or equal operation on a float2 vector and a float value</summary>
    /// <param name="left">Left hand side float2 vector for less than or equal</param>
    /// <param name="right">Right hand side float value for less than or equal</param>
    /// <returns>Componentwise less than or equal result</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool2 operator <=(in float2 left, in float right) {
        return new bool2(left.x <= right, left.y <= right);
    }

    /// <summary>Componentwise less than or equal operation on a float value and a float2 vector</summary>
    /// <param name="left">Left hand side float value for less than or equal</param>
    /// <param name="right">Right hand side float2 vector for less than or equal</param>
    /// <returns>Componentwise less than or equal result</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool2 operator <=(in float left, in float2 right) {
        return new bool2(left <= right.x, left <= right.y);
    }

    /// <summary>Componentwise greater than operation on two float2 vectors</summary>
    /// <param name="left">Left hand side float2 vector for greater than</param>
    /// <param name="right">Right hand side float2 vector for greater than</param>
    /// <returns>Componentwise greater than result</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool2 operator >(in float2 left, in float2 right) {
        return new bool2(left.x > right.x, left.y > right.y);
    }

    /// <summary>Componentwise greater than operation on a float2 vector and a float value</summary>
    /// <param name="left">Left hand side float2 vector for greater than</param>
    /// <param name="right">Right hand side float value for greater than</param>
    /// <returns>Componentwise greater than result</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool2 operator >(in float2 left, in float right) {
        return new bool2(left.x > right, left.y > right);
    }

    /// <summary>Componentwise greater than operation on a float value and a float2 vector</summary>
    /// <param name="left">Left hand side float value for greater than</param>
    /// <param name="right">Right hand side float2 vector for greater than</param>
    /// <returns>Componentwise greater than result</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool2 operator >(in float left, in float2 right) {
        return new bool2(left > right.x, left > right.y);
    }

    /// <summary>Componentwise greater than or equal operation on two float2 vectors</summary>
    /// <param name="left">Left hand side float2 vector for greater than or equal</param>
    /// <param name="right">Right hand side float2 vector for greater than or equal</param>
    /// <returns>Componentwise greater than or equal result</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool2 operator >=(in float2 left, in float2 right) {
        return new bool2(left.x >= right.x, left.y >= right.y);
    }

    /// <summary>Componentwise greater than or equal operation on a float2 vector and a float value</summary>
    /// <param name="left">Left hand side float2 vector for greater than or equal</param>
    /// <param name="right">Right hand side float value for greater than or equal</param>
    /// <returns>Componentwise greater than or equal result</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool2 operator >=(in float2 left, in float right) {
        return new bool2(left.x >= right, left.y >= right);
    }

    /// <summary>Componentwise greater than or equal operation on a float value and a float2 vector</summary>
    /// <param name="left">Left hand side float value for greater than or equal</param>
    /// <param name="right">Right hand side float2 vector for greater than or equal</param>
    /// <returns>Componentwise greater than or equal result</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool2 operator >=(in float left, in float2 right) {
        return new bool2(left >= right.x, left >= right.y);
    }

    /// <summary>Componentwise equality operation on two float2 vectors</summary>
    /// <param name="left">Left hand side float2 vector for equality</param>
    /// <param name="right">Right hand side float2 vector for equality</param>
    /// <returns>Componentwise equality result</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool2 operator ==(in float2 left, in float2 right) {
        return new bool2(left.x == right.x, left.y == right.y);
    }

    /// <summary>Componentwise equality operation on a float2 vector and a float value</summary>
    /// <param name="left">Left hand side float2 vector for equality</param>
    /// <param name="right">Right hand side float value for equality</param>
    /// <returns>Componentwise equality result</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool2 operator ==(in float2 left, in float right) {
        return new bool2(left.x == right, left.y == right);
    }

    /// <summary>Componentwise equality operation on a float value and a float2 vector</summary>
    /// <param name="left">Left hand side float value for equality</param>
    /// <param name="right">Right hand side float2 vector for equality</param>
    /// <returns>Componentwise equality result</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool2 operator ==(in float left, in float2 right) {
        return new bool2(left == right.x, left == right.y);
    }

    /// <summary>Componentwise inequality operation on two float2 vectors</summary>
    /// <param name="left">Left hand side float2 vector for inequality</param>
    /// <param name="right">Right hand side float2 vector for inequality</param>
    /// <returns>Componentwise inequality result</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool2 operator !=(in float2 left, in float2 right) {
        return new bool2(left.x != right.x, left.y != right.y);
    }

    /// <summary>Componentwise inequality operation on a float2 vector and a float value</summary>
    /// <param name="left">Left hand side float2 vector for inequality</param>
    /// <param name="right">Right hand side float value for inequality</param>
    /// <returns>Componentwise inequality result</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool2 operator !=(in float2 left, in float right) {
        return new bool2(left.x != right, left.y != right);
    }

    /// <summary>Componentwise inequality operation on a float value and a float2 vector</summary>
    /// <param name="left">Left hand side float value for inequality</param>
    /// <param name="right">Right hand side float2 vector for inequality</param>
    /// <returns>Componentwise inequality result</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool2 operator !=(in float left, in float2 right) {
        return new bool2(left != right.x, left != right.y);
    }

    #endregion Operators

    #region Swizzle

    /// <summary>Swizzles the float2 vector</summary>
    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
    public float2 xx {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => new float2(x, x);
    }

    /// <summary>Swizzles the float2 vector</summary>
    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
    public float2 xy {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => new float2(x, y);
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set {
            this.x = value.x;
            this.y = value.y;
        }
    }

    /// <summary>Swizzles the float2 vector</summary>
    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
    public float2 yx {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => new float2(y, x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set {
            this.y = value.x;
            this.x = value.y;
        }
    }

    /// <summary>Swizzles the float2 vector</summary>
    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
    public float2 yy {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => new float2(y, y);
    }

    #endregion Swizzle

    #region Equals

    /// <inheritdoc/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public override int GetHashCode() {
        return HashCode.Combine(x, y);
    }

    /// <inheritdoc/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool Equals(float2 other) {
        return x == other.x && y == other.y;
    }

    /// <inheritdoc/>
    public override bool Equals([NotNullWhen(true)] object? obj) => obj is float2 value && Equals(value);

    #endregion Equals

    #region ToString

    /// <summary>Returns a string that represents the current values</summary>
    /// <returns>The values of the current instance with the specified format</returns>
    public override string ToString() {
        return string.Format("float2({0} {1})", x, y);
    }

    /// <summary>Formats the values of the current instance using the specified format</summary>
    /// <param name="format">The format to use</param>
    /// <param name="formatProvider">The provider to use to format the values</param>
    /// <returns>The values of the current instance with the specified format</returns>
    public string ToString(string? format, IFormatProvider? formatProvider) {
        return string.Format("float2({0} {1})", x.ToString(format, formatProvider), y.ToString(format, formatProvider));
    }

    #endregion ToString
}

public static unsafe partial class math {
    #region Component Math

    /// <summary>Returns the bit pattern of a float2 vector as an int2 vector</summary>
    /// <param name="value">The float2 bits to copy</param>
    /// <returns>The int2 with the same bit pattern as the input</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static int2 asint(float2 value) {
        return *(int2*)&value;
    }

    /// <summary>Minimum of two float2 vectors</summary>
    /// <param name="x">The first of two values to compare</param>
    /// <param name="y">The second of two values to compare</param>
    /// <returns>Componentwise Minimum</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 min(in float2 x, in float2 y) {
        return new float2(math.min(x.x, y.x), math.min(x.y, y.y));
    }
    /// <summary>Maximum of two float2 vectors</summary>
    /// <param name="x">The first of two values to compare</param>
    /// <param name="y">The second of two values to compare</param>
    /// <returns>Componentwise Maximum</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 max(in float2 x, in float2 y) {
        return new float2(math.max(x.x, y.x), math.max(x.y, y.y));
    }
    /// <summary>Returns the result of clamping the value x into the interval [a, b], where x, a and b are byte values</summary>
    /// <param name="x">Input value to be clamped</param>
    /// <param name="a">Lower bound of the interval</param>
    /// <param name="b">Upper bound of the interval</param>
    /// <returns>The clamping of the input x into the interval [a, b]</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 clamp(in float2 x, in float2 a, in float2 b) {
        return max(a, min(b, x));
    }
    /// <summary>Tests each component of a float2 vector whether it is a finite value</summary>
    /// <param name="x">Value to test</param>
    /// <returns>True if the component is a finite value, false otherwise</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool2 isfinite(in float2 x) {
        return abs(x) < float.PositiveInfinity;
    }
    /// <summary>Tests each component of a float2 vector whether it is an infinite value</summary>
    /// <param name="x">Value to test</param>
    /// <returns>True if the component is an infinite value, false otherwise</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool2 isinf(in float2 x) {
        return abs(x) == float.PositiveInfinity;
    }
    /// <summary>Tests each component of a float2 vector whether it is NaN value</summary>
    /// <param name="x">Value to test</param>
    /// <returns>True if the component is NaN, false otherwise</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool2 isnan(in float2 x) {
        return new bool2(math.isnan(x.x), math.isnan(x.y));
    }
    /// <summary>Performs a linear interpolation</summary>
    /// <param name="x">The first value</param>
    /// <param name="y">The second value</param>
    /// <param name="s">A value that linearly interpolates between the x and y parameter</param>
    /// <returns>Interpolated value</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 lerp(in float2 x, in float2 y, in float2 s) {
        return x + s * (y - x);
    }
    /// <summary>Returns the result of normalizing a value x to a range [a, b]. The opposite of lerp. Equivalent to (x - a) / (b - a)</summary>
    /// <param name="a">The first endpoint of the range</param>
    /// <param name="b">The second endpoint of the range</param>
    /// <param name="x">The value to normalize to the range</param>
    /// <returns>The interpolation parameter of x with respect to the input range [a, b]</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 unlerp(in float2 a, in float2 b, in float2 x) {
        return (x - a) / (b - a);
    }
    /// <summary>Returns the result of a linear remapping of a value x from source to destination range</summary>
    /// <param name="srcMin">Source minimum</param>
    /// <param name="srcMax">Source maximum</param>
    /// <param name="dstMin">Destination minimum</param>
    /// <param name="dstMax">Destination maximum</param>
    /// <param name="x">The value to remap from the source to destination range</param>
    /// <returns>Remaps x from the source to destination range</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 remap(in float2 srcMin, in float2 srcMax, in float2 dstMin, in float2 dstMax, in float2 x) {
        return lerp(dstMin, dstMax, unlerp(srcMin, srcMax, x));
    }
    /// <summary>Returns the result of clamping the float value x into the interval [0, 1]</summary>
    /// <param name="x">Input value</param>
    /// <returns>The clamping of the input into the interval [0, 1]</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 saturate(in float2 x) {
        return clamp(x, 0f, 1f);
    }
    /// <summary>Returns the absolute value of a float2 vector</summary>
    /// <param name="x">Input value</param>
    /// <returns>The absolute value of the input</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 abs(in float2 x) {
        return new float2(math.abs(x.x), math.abs(x.y));
    }
    /// <summary>Returns the sign of a float2 vector value. -1 if it is less than zero, 0 if it is zero and 1 if it greater than zero</summary>
    /// <param name="x">Input value</param>
    /// <returns>The sign of the input</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static int2 sign(in float2 x) {
        return new int2(math.sign(x.x), math.sign(x.y));
    }
    /// <summary>Returns the dot product of two float2 vectors values. Equivalent to multiplication</summary>
    /// <param name="x">The first value</param>
    /// <param name="y">The second value</param>
    /// <returns>The dot product of two values</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float dot(in float2 x, in float2 y) {
        return x.x * y.x + x.y * y.y;
    }
    /// <summary>Returns the tangent of a float2 vector</summary>
    /// <param name="x">Input value</param>
    /// <returns>The tangent of the input</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 tan(in float2 x) {
        return new float2(math.tan(x.x), math.tan(x.y));
    }
    /// <summary>Returns the hyperbolic tangent of a float2 vector</summary>
    /// <param name="x">Input value</param>
    /// <returns>The hyperbolic tangent of the input</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 tanh(in float2 x) {
        return new float2(math.tanh(x.x), math.tanh(x.y));
    }
    /// <summary>Returns the arctangent of a float2 vector</summary>
    /// <param name="x">A tangent value, usually the ratio y/x on the unit circle</param>
    /// <returns>The arctangent of the input, in radians</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 atan(in float2 x) {
        return new float2(math.atan(x.x), math.atan(x.y));
    }
    /// <summary>Returns the 2-argument arctangent of a pair of float2 values</summary>
    /// <param name="y">Numerator of the ratio y/x, usually the y component on the unit circle</param>
    /// <param name="x">Denominator of the ratio y/x, usually the x component on the unit circle</param>
    /// <returns>The arctangent of the ratio y/x, in radians</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 atan2(in float2 y, in float2 x) {
        return new float2(math.atan2(y.x, x.x), math.atan2(y.y, x.y));
    }
    /// <summary>Returns the cosine of a float2 vector</summary>
    /// <param name="x">Input value</param>
    /// <returns>The cosine of the input</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 cos(in float2 x) {
        return new float2(math.cos(x.x), math.cos(x.y));
    }
    /// <summary>Returns the hyperbolic cosine of a float2 vector</summary>
    /// <param name="x">Input value</param>
    /// <returns>The hyperbolic cosine of the input</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 cosh(in float2 x) {
        return new float2(math.cosh(x.x), math.cosh(x.y));
    }
    /// <summary>Returns the arccosine of a float2 vector</summary>
    /// <param name="x">Input value</param>
    /// <returns>The arccosine of the input</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 acos(in float2 x) {
        return new float2(math.acos(x.x), math.acos(x.y));
    }
    /// <summary>Returns the sine of a float2 vector</summary>
    /// <param name="x">Input value</param>
    /// <returns>The sine of the input</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 sin(in float2 x) {
        return new float2(math.sin(x.x), math.sin(x.y));
    }
    /// <summary>Returns the hyperbolic sine of a float2 vector</summary>
    /// <param name="x">Input value</param>
    /// <returns>The hyperbolic sine of the input</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 sinh(in float2 x) {
        return new float2(math.sinh(x.x), math.sinh(x.y));
    }
    /// <summary>Returns the arcsine of a float2 vector</summary>
    /// <param name="x">Input value</param>
    /// <returns>The arcsine of the input</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 asin(in float2 x) {
        return new float2(math.asin(x.x), math.asin(x.y));
    }
    /// <summary>Returns the result of rounding a float2 vector down to the nearest integral value less or equal to the original value</summary>
    /// <param name="x">Input value</param>
    /// <returns>The round down to nearest integral value of the input</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 floor(in float2 x) {
        return new float2(math.floor(x.x), math.floor(x.y));
    }
    /// <summary>Returns the result of rounding a float2 vector up to the nearest integral value greater or equal to the original value</summary>
    /// <param name="x">Input value</param>
    /// <returns>The round up to nearest integral value of the input</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 ceil(in float2 x) {
        return new float2(math.ceil(x.x), math.ceil(x.y));
    }
    /// <summary>Returns the result of rounding a float2 vector to the nearest integral value</summary>
    /// <param name="x">Input value</param>
    /// <returns>The round to nearest integral value of the input</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 round(in float2 x) {
        return new float2(math.round(x.x), math.round(x.y));
    }
    /// <summary>Returns the result of truncating a float2 vector to an integral float2 value</summary>
    /// <param name="x">Input value</param>
    /// <returns>The truncation of the input</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 trunc(in float2 x) {
        return new float2(math.trunc(x.x), math.trunc(x.y));
    }
    /// <summary>Returns the fractional part of a float2 vector</summary>
    /// <param name="x">Input value</param>
    /// <returns>The fractional part of the input</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 frac(in float2 x) {
        return x - floor(x);
    }
    /// <summary>Returns the reciprocal a float2 vector</summary>
    /// <param name="x">Input value</param>
    /// <returns>The reciprocal of the input</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 rcp(in float2 x) {
        return 1f / x;
    }
    /// <summary>Returns x raised to the power y</summary>
    /// <param name="x">The exponent base</param>
    /// <param name="y">The exponent exponent</param>
    /// <returns>The result of raising x to the power y</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 pow(in float2 x, in float2 y) {
        return new float2(math.pow(x.x, y.x), math.pow(x.y, y.y));
    }
    /// <summary>Returns the base-e exponential of x</summary>
    /// <param name="x">Input value</param>
    /// <returns>The base-e exponential of the input</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 exp(in float2 x) {
        return new float2(math.exp(x.x), math.exp(x.y));
    }
    /// <summary>Returns the base-2 exponential of x</summary>
    /// <param name="x">Input value</param>
    /// <returns>The base-2 exponential of the input</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 exp2(in float2 x) {
        return new float2(math.exp2(x.x), math.exp2(x.y));
    }
    /// <summary>Returns the base-10 exponential of x</summary>
    /// <param name="x">Input value</param>
    /// <returns>The base-10 exponential of the input</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 exp10(in float2 x) {
        return new float2(math.exp10(x.x), math.exp10(x.y));
    }
    /// <summary>Returns the natural logarithm of a double value</summary>
    /// <param name="x">Input value</param>
    /// <returns>The natural logarithm of the input</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 log(in float2 x) {
        return new float2(math.log(x.x), math.log(x.y));
    }
    /// <summary>Returns the base-2 logarithm of a double value</summary>
    /// <param name="x">Input value</param>
    /// <returns>The base-2 logarithm of the input</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 log2(in float2 x) {
        return new float2(math.log2(x.x), math.log2(x.y));
    }
    /// <summary>Returns the base-10 logarithm of a double value</summary>
    /// <param name="x">Input value</param>
    /// <returns>The base-10 logarithm of the input</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 log10(in float2 x) {
        return new float2(math.log10(x.x), math.log10(x.y));
    }
    /// <summary>Returns the floating point remainder of x/y</summary>
    /// <param name="x">The dividend in x/y</param>
    /// <param name="y">The divisor in x/y</param>
    /// <returns>The remainder of x/y</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 fmod(in float2 x, in float2 y) {
        return x % y;
    }
    /// <summary>Splits a float2 vector into an integral part i and a fractional part that gets returned. Both parts take the sign of the input</summary>
    /// <param name="x">Value to split into integral and fractional part</param>
    /// <param name="i">Output value containing integral part of x</param>
    /// <returns>The fractional part of x</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 modf(in float2 x, out float2 i) {
        i = trunc(x); return x - i;
    }
    /// <summary>Returns the square root of a float2 vector</summary>
    /// <param name="x">Value to use when computing square root</param>
    /// <returns>The square root</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 sqrt(in float2 x) {
        return new float2(math.sqrt(x.x), math.sqrt(x.y));
    }
    /// <summary>Returns the reciprocal square root of a float2 vector</summary>
    /// <param name="x">Value to use when computing reciprocal square root</param>
    /// <returns>The reciprocal square root</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 rsqrt(in float2 x) {
        return 1f / sqrt(x);
    }
    /// <summary>Returns a normalized float2 vector</summary>
    /// <param name="x">Vector to normalize</param>
    /// <returns>Normalized Vector</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 normalize(in float2 x) {
        return rsqrt(lengthsq(x)) * x;
    }
    /// <summary>Returns a normalized float2 vector. Fallback to default value if normalized vector is not finite</summary>
    /// <param name="x">Vector to normalize</param>
    /// <param name="defaultValue">Default value to return if normalized vector is not finite</param>
    /// <returns>Normalized Vector</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 normalizesafe(in float2 x, in float2 defaultValue = default) {
        float len = lengthsq(x);
        return select(defaultValue, x * rsqrt(len), len > MIN_NORMAL);
    }
    /// <summary>Returns the length of a float2 vector</summary>
    /// <param name="x">Vector to use when computing length</param>
    /// <returns>Length of vector x</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float length(in float2 x) {
        return sqrt(dot(x, x));
    }
    /// <summary>Returns the squared length of a float2 vector</summary>
    /// <param name="x">Vector to use when computing squared length</param>
    /// <returns>Squared length of vector x</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float lengthsq(in float2 x) {
        return dot(x, x);
    }
    /// <summary>Returns the distance between two float2 vectors</summary>
    /// <param name="x">First vector to use in distance computation</param>
    /// <param name="y">Second vector to use in distance computation</param>
    /// <returns>The distance between x and y</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float distance(in float2 x, in float2 y) {
        return length(y - x);
    }
    /// <summary>Returns the squared distance between two float2 vectors</summary>
    /// <param name="x">First vector to use in distance computation</param>
    /// <param name="y">Second vector to use in distance computation</param>
    /// <returns>The squared distance between x and y</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float distancesq(in float2 x, in float2 y) {
        return lengthsq(y - x);
    }
    /// <summary>Returns a smooth Hermite interpolation between 0f and 1f when x is in [a, b]</summary>
    /// <param name="a">The minimum range of the x parameter</param>
    /// <param name="b">The maximum range of the x parameter</param>
    /// <param name="x">The value to be interpolated</param>
    /// <returns>Returns a value camped to the range [0, 1]</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 smoothstep(in float2 a, in float2 b, in float2 x) {
        var t = saturate((x - a) / (b - a));
        return t * t * (3f - (2f * t));
    }
    /// <summary>Returns the result of a componentwise step function where each component is 1f when x >= y and 0f otherwise</summary>
    /// <param name="y">Vector of values to be used as a threshold for returning 1</param>
    /// <param name="x">Vector of values to compare against threshold y</param>
    /// <returns>1 if the componentwise comparison x >= y is true, otherwise 0</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 step(in float2 y, in float2 x) {
        return select(new float2(0f), new float2(1f), x >= y);
    }
    /// <summary>Given an incident vector i and a normal vector n, returns the reflection vector r = i - 2 * dot(i, n) * n</summary>
    /// <param name="i">Incident vector</param>
    /// <param name="n">Normal vector</param>
    /// <returns>Reflection vector</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 reflect(in float2 i, in float2 n) {
        return i - 2f * n * dot(i, n);
    }
    /// <summary>Returns the refraction vector given the incident vector i, the normal vector n and the refraction index eta</summary>
    /// <param name="i">Incident vector</param>
    /// <param name="n">Normal vector</param>
    /// <param name="eta">Index of refraction</param>
    /// <returns>Refraction vector</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 refract(in float2 i, in float2 n, in float eta) {
        float ni = dot(n, i);
        float k = 1f - eta * eta * (1f - ni * ni);
        return select(0f, eta * i - (eta * ni + sqrt(k)) * n, k < 0f);
    }
    /// <summary>Compute vector projection of a onto b</summary>
    /// <param name="a">Vector to project</param>
    /// <param name="b">Non-zero vector to project onto</param>
    /// <returns>Vector projection of a onto b</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 project(in float2 a, in float2 b) {
        return (dot(a, b) / dot(b, b)) * b;
    }
    /// <summary>Compute vector projection of a onto b. If result is not finite, then return the default value instead</summary>
    /// <param name="a">Vector to project</param>
    /// <param name="b">Non-zero vector to project onto</param>
    /// <param name="defaultValue">Default value to return if projection is not finite</param>
    /// <returns>Vector projection of a onto b or the default value</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 projectsafe(in float2 a, in float2 b, in float2 defaultValue = default) {
        var proj = project(a, b);
        return select(defaultValue, proj, all(isfinite(proj)));
    }
    /// <summary>Conditionally flips a vector n if two vectors i and ng are pointing in the same direction. Returns n if dot(i, ng) < 0, -n otherwise</summary>
    /// <param name="n">Vector to conditionally flip</param>
    /// <param name="i">First vector in direction comparison</param>
    /// <param name="ng">Second vector in direction comparison</param>
    /// <returns>-n if i and ng point in the same direction; otherwise return n unchanged</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 faceforward(in float2 n, in float2 i, in float2 ng) {
        return select(n, -n, dot(ng, i) >= 0f);
    }
    /// <summary>Returns the componentwise sine and cosine of the input float2 vector x through the out parameters s and c</summary>
    /// <param name="x">Input vector containing angles in radians</param>
    /// <param name="s">Output vector containing the componentwise sine of the input</param>
    /// <param name="c">Output vector containing the componentwise cosine of the input</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void sincos(in float2 x, out float2 s, out float2 c) {
        sincos(x.x, out s.x, out c.x);
        sincos(x.y, out s.y, out c.y);
    }
    /// <summary>Returns the result of converting a float2 vector value from degrees to radians</summary>
    /// <param name="x">Vector containing angles in degrees</param>
    /// <returns>Vector containing angles converted to radians</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 radians(in float2 x) {
        return x * (PI / 180f);
    }
    /// <summary>Returns the result of converting a float2 vector value from radians to degrees</summary>
    /// <param name="x">Vector containing angles in radians</param>
    /// <returns>Vector containing angles converted to degrees</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 degrees(in float2 x) {
        return x * (180f / PI);
    }
    /// <summary>Returns the minimum component of a float2 vector</summary>
    /// <param name="x">The vector to use when computing the minimum component</param>
    /// <returns>The value of the minimum component of the vector</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float cmin(in float2 x) {
        return min(x.x, x.y);
    }
    /// <summary>Returns the maximum component of a float2 vector</summary>
    /// <param name="x">The vector to use when computing the maximum component</param>
    /// <returns>The value of the maximum component of the vector</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float cmax(in float2 x) {
        return max(x.x, x.y);
    }
    /// <summary>Returns the horizontal sum of components of a float2 vector</summary>
    /// <param name="x">The vector to use when computing the horizontal sum</param>
    /// <returns>The horizontal sum of of components of the vector</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float csum(in float2 x) {
        return x.x + x.y;
    }
    /// <summary>Returns b if c is true, a otherwise</summary>
    /// <param name="a">Value to use if c is false</param>
    /// <param name="b">Value to use if c is false</param>
    /// <param name="c">Bool value to choose between a and b</param>
    /// <returns>The selection between a and b according to bool c</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 select(in float2 a, in float2 b, in bool c) {
        return c ? b : a;
    }
    /// <summary>Returns a componentwise selection between two float2 vectors a and b based on a bool2 vector selection mask c. Per component, the component from b is selected when c is true, otherwise the component from a is selected</summary>
    /// <param name="a">Value to use if c is false</param>
    /// <param name="b">Value to use if c is false</param>
    /// <param name="c">Selection mask to choose between a and b</param>
    /// <returns>The componentwise selection between a and b according to selection mask c</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float2 select(in float2 a, in float2 b, in bool2 c) {
        return new float2(math.select(a.x, b.x, c.x), math.select(a.y, b.y, c.y));
    }
    #endregion Component Math

}
