//------------------------------------------------------------------------------
// <auto-generated>
// This code was generated by a tool
// Runtime Version: 1.0.0.0
//
// Changes to this file may cause incorrect behavior and will be lost if
// the code is regenerated
// </auto-generated>
//------------------------------------------------------------------------------
#nullable enable

using System;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace HellEngine.Mathematics;

public static unsafe partial class math {
    #region Constants

    /// <summary>The mathematical constant e also known as Euler's number</summary>
    public const float E = (float)2.71828182845904523536;

    /// <summary>The base 2 logarithm of e</summary>
    public const float LOG2E = (float)1.44269504088896340736;

    /// <summary>The base 10 logarithm of e</summary>
    public const float LOG10E = (float)0.434294481903251827651;

    /// <summary>The natural logarithm of 2</summary>
    public const float LN2 = (float)0.693147180559945309417;

    /// <summary>The natural logarithm of 10</summary>
    public const float LN10 = (float)2.30258509299404568402;

    /// <summary>The mathematical constant pi</summary>
    public const float PI = (float)3.14159265358979323846;

    /// <summary>The square root 2</summary>
    public const float SQRT2 = (float)1.41421356237309504880;

    /// <summary>The difference between 1.0f and the next representable single precision number</summary>
    public const float EPSILON_ONE = 1.1920928955078125e-7f;

    /// <summary>The smallest positive normal number representable in a float</summary>
    public const float MIN_NORMAL = 1.175494351e-38f;

    #endregion Constants

    #region Component Math

    /// <summary>Returns the bit pattern of a float value as an int value</summary>
    /// <param name="value">The float bits to copy</param>
    /// <returns>The int with the same bit pattern as the input</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static int asint(float value) {
        return *(int*)&value;
    }
    /// <summary>Returns the bit pattern of a float value as an uint value</summary>
    /// <param name="value">The float bits to copy</param>
    /// <returns>The uint with the same bit pattern as the input</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static uint asuint(float value) {
        return *(uint*)&value;
    }
    /// <summary>Minimum of two float values</summary>
    /// <param name="x">The first of two values to compare</param>
    /// <param name="y">The second of two values to compare</param>
    /// <returns>Componentwise Minimum</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float min(in float x, in float y) {
        return x < y ? x : y;
    }
    /// <summary>Maximum of two float values</summary>
    /// <param name="x">The first of two values to compare</param>
    /// <param name="y">The second of two values to compare</param>
    /// <returns>Componentwise Maximum</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float max(in float x, in float y) {
        return x > y ? x : y;
    }
    /// <summary>Returns the result of clamping the value x into the interval [a, b], where x, a and b are byte values</summary>
    /// <param name="x">Input value to be clamped</param>
    /// <param name="a">Lower bound of the interval</param>
    /// <param name="b">Upper bound of the interval</param>
    /// <returns>The clamping of the input x into the interval [a, b]</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float clamp(in float x, in float a, in float b) {
        return max(a, min(b, x));
    }
    /// <summary>Tests each component of a float value whether it is a finite value</summary>
    /// <param name="x">Value to test</param>
    /// <returns>True if the component is a finite value, false otherwise</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool isfinite(in float x) {
        return abs(x) < float.PositiveInfinity;
    }
    /// <summary>Tests each component of a float value whether it is an infinite value</summary>
    /// <param name="x">Value to test</param>
    /// <returns>True if the component is an infinite value, false otherwise</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool isinf(in float x) {
        return abs(x) == float.PositiveInfinity;
    }
    /// <summary>Tests each component of a float value whether it is NaN value</summary>
    /// <param name="x">Value to test</param>
    /// <returns>True if the component is NaN, false otherwise</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool isnan(in float x) {
        return (asint(x) & 0x7FFFFFFF) > 0x7F800000;
    }
    /// <summary>Performs a linear interpolation</summary>
    /// <param name="x">The first value</param>
    /// <param name="y">The second value</param>
    /// <param name="s">A value that linearly interpolates between the x and y parameter</param>
    /// <returns>Interpolated value</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float lerp(in float x, in float y, in float s) {
        return x + s * (y - x);
    }
    /// <summary>Returns the result of normalizing a value x to a range [a, b]. The opposite of lerp. Equivalent to (x - a) / (b - a)</summary>
    /// <param name="a">The first endpoint of the range</param>
    /// <param name="b">The second endpoint of the range</param>
    /// <param name="x">The value to normalize to the range</param>
    /// <returns>The interpolation parameter of x with respect to the input range [a, b]</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float unlerp(in float a, in float b, in float x) {
        return (x - a) / (b - a);
    }
    /// <summary>Returns the result of a linear remapping of a value x from source to destination range</summary>
    /// <param name="srcMin">Source minimum</param>
    /// <param name="srcMax">Source maximum</param>
    /// <param name="dstMin">Destination minimum</param>
    /// <param name="dstMax">Destination maximum</param>
    /// <param name="x">The value to remap from the source to destination range</param>
    /// <returns>Remaps x from the source to destination range</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float remap(in float srcMin, in float srcMax, in float dstMin, in float dstMax, in float x) {
        return lerp(dstMin, dstMax, unlerp(srcMin, srcMax, x));
    }
    /// <summary>Returns the result of clamping the float value x into the interval [0, 1]</summary>
    /// <param name="x">Input value</param>
    /// <returns>The clamping of the input into the interval [0, 1]</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float saturate(in float x) {
        return clamp(x, 0f, 1f);
    }
    /// <summary>Returns the absolute value of a float value</summary>
    /// <param name="x">Input value</param>
    /// <returns>The absolute value of the input</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float abs(in float x) {
        return MathF.Abs(x);
    }
    /// <summary>Returns the sign of a float value value. -1 if it is less than zero, 0 if it is zero and 1 if it greater than zero</summary>
    /// <param name="x">Input value</param>
    /// <returns>The sign of the input</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static int sign(in float x) {
        return MathF.Sign(x);
    }
    /// <summary>Returns the dot product of two float values values. Equivalent to multiplication</summary>
    /// <param name="x">The first value</param>
    /// <param name="y">The second value</param>
    /// <returns>The dot product of two values</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float dot(in float x, in float y) {
        return x * y;
    }
    /// <summary>Returns the tangent of a float value</summary>
    /// <param name="x">Input value</param>
    /// <returns>The tangent of the input</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float tan(in float x) {
        return (float)MathF.Tan(x);
    }
    /// <summary>Returns the hyperbolic tangent of a float value</summary>
    /// <param name="x">Input value</param>
    /// <returns>The hyperbolic tangent of the input</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float tanh(in float x) {
        return (float)MathF.Tanh(x);
    }
    /// <summary>Returns the arctangent of a float value</summary>
    /// <param name="x">A tangent value, usually the ratio y/x on the unit circle</param>
    /// <returns>The arctangent of the input, in radians</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float atan(in float x) {
        return (float)MathF.Atan(x);
    }
    /// <summary>Returns the 2-argument arctangent of a pair of float values</summary>
    /// <param name="y">Numerator of the ratio y/x, usually the y component on the unit circle</param>
    /// <param name="x">Denominator of the ratio y/x, usually the x component on the unit circle</param>
    /// <returns>The arctangent of the ratio y/x, in radians</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float atan2(in float y, in float x) {
        return (float)MathF.Atan2(y, x);
    }
    /// <summary>Returns the cosine of a float value</summary>
    /// <param name="x">Input value</param>
    /// <returns>The cosine of the input</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float cos(in float x) {
        return (float)MathF.Cos(x);
    }
    /// <summary>Returns the hyperbolic cosine of a float value</summary>
    /// <param name="x">Input value</param>
    /// <returns>The hyperbolic cosine of the input</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float cosh(in float x) {
        return (float)MathF.Cosh(x);
    }
    /// <summary>Returns the arccosine of a float value</summary>
    /// <param name="x">Input value</param>
    /// <returns>The arccosine of the input</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float acos(in float x) {
        return (float)MathF.Acos(x);
    }
    /// <summary>Returns the sine of a float value</summary>
    /// <param name="x">Input value</param>
    /// <returns>The sine of the input</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float sin(in float x) {
        return (float)MathF.Sin(x);
    }
    /// <summary>Returns the hyperbolic sine of a float value</summary>
    /// <param name="x">Input value</param>
    /// <returns>The hyperbolic sine of the input</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float sinh(in float x) {
        return (float)MathF.Sinh(x);
    }
    /// <summary>Returns the arcsine of a float value</summary>
    /// <param name="x">Input value</param>
    /// <returns>The arcsine of the input</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float asin(in float x) {
        return (float)MathF.Asin(x);
    }
    /// <summary>Returns the result of rounding a float value down to the nearest integral value less or equal to the original value</summary>
    /// <param name="x">Input value</param>
    /// <returns>The round down to nearest integral value of the input</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float floor(in float x) {
        return (float)MathF.Floor(x);
    }
    /// <summary>Returns the result of rounding a float value up to the nearest integral value greater or equal to the original value</summary>
    /// <param name="x">Input value</param>
    /// <returns>The round up to nearest integral value of the input</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float ceil(in float x) {
        return (float)MathF.Ceiling(x);
    }
    /// <summary>Returns the result of rounding a float value to the nearest integral value</summary>
    /// <param name="x">Input value</param>
    /// <returns>The round to nearest integral value of the input</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float round(in float x) {
        return (float)MathF.Round(x);
    }
    /// <summary>Returns the result of truncating a float value to an integral float value</summary>
    /// <param name="x">Input value</param>
    /// <returns>The truncation of the input</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float trunc(in float x) {
        return (float)MathF.Truncate(x);
    }
    /// <summary>Returns the fractional part of a float value</summary>
    /// <param name="x">Input value</param>
    /// <returns>The fractional part of the input</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float frac(in float x) {
        return x - floor(x);
    }
    /// <summary>Returns the reciprocal a float value</summary>
    /// <param name="x">Input value</param>
    /// <returns>The reciprocal of the input</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float rcp(in float x) {
        return 1f / x;
    }
    /// <summary>Returns x raised to the power y</summary>
    /// <param name="x">The exponent base</param>
    /// <param name="y">The exponent exponent</param>
    /// <returns>The result of raising x to the power y</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float pow(in float x, in float y) {
        return (float)MathF.Pow(x, y);
    }
    /// <summary>Returns the base-e exponential of x</summary>
    /// <param name="x">Input value</param>
    /// <returns>The base-e exponential of the input</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float exp(in float x) {
        return (float)MathF.Exp(x);
    }
    /// <summary>Returns the base-2 exponential of x</summary>
    /// <param name="x">Input value</param>
    /// <returns>The base-2 exponential of the input</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float exp2(in float x) {
        return (float)MathF.Exp(x * LN2);
    }
    /// <summary>Returns the base-10 exponential of x</summary>
    /// <param name="x">Input value</param>
    /// <returns>The base-10 exponential of the input</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float exp10(in float x) {
        return (float)MathF.Exp(x * LN10);
    }
    /// <summary>Returns the natural logarithm of a double value</summary>
    /// <param name="x">Input value</param>
    /// <returns>The natural logarithm of the input</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float log(in float x) {
        return (float)MathF.Log(x);
    }
    /// <summary>Returns the base-2 logarithm of a double value</summary>
    /// <param name="x">Input value</param>
    /// <returns>The base-2 logarithm of the input</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float log2(in float x) {
        return (float)MathF.Log(x, 2f);
    }
    /// <summary>Returns the base-10 logarithm of a double value</summary>
    /// <param name="x">Input value</param>
    /// <returns>The base-10 logarithm of the input</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float log10(in float x) {
        return (float)MathF.Log10(x);
    }
    /// <summary>Returns the floating point remainder of x/y</summary>
    /// <param name="x">The dividend in x/y</param>
    /// <param name="y">The divisor in x/y</param>
    /// <returns>The remainder of x/y</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float fmod(in float x, in float y) {
        return x % y;
    }
    /// <summary>Splits a float value into an integral part i and a fractional part that gets returned. Both parts take the sign of the input</summary>
    /// <param name="x">Value to split into integral and fractional part</param>
    /// <param name="i">Output value containing integral part of x</param>
    /// <returns>The fractional part of x</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float modf(in float x, out float i) {
        i = trunc(x); return x - i;
    }
    /// <summary>Returns the square root of a float value</summary>
    /// <param name="x">Value to use when computing square root</param>
    /// <returns>The square root</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float sqrt(in float x) {
        return (float)MathF.Sqrt(x);
    }
    /// <summary>Returns the reciprocal square root of a float value</summary>
    /// <param name="x">Value to use when computing reciprocal square root</param>
    /// <returns>The reciprocal square root</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float rsqrt(in float x) {
        return 1f / sqrt(x);
    }
    /// <summary>Returns the length of a float value</summary>
    /// <param name="x">Vector to use when computing length</param>
    /// <returns>Length of vector x</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float length(in float x) {
        return abs(x);
    }
    /// <summary>Returns the squared length of a float value</summary>
    /// <param name="x">Vector to use when computing squared length</param>
    /// <returns>Squared length of vector x</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float lengthsq(in float x) {
        return dot(x, x);
    }
    /// <summary>Returns the distance between two float values</summary>
    /// <param name="x">First vector to use in distance computation</param>
    /// <param name="y">Second vector to use in distance computation</param>
    /// <returns>The distance between x and y</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float distance(in float x, in float y) {
        return abs(y - x);
    }
    /// <summary>Returns the squared distance between two float values</summary>
    /// <param name="x">First vector to use in distance computation</param>
    /// <param name="y">Second vector to use in distance computation</param>
    /// <returns>The squared distance between x and y</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float distancesq(in float x, in float y) {
        return lengthsq(y - x);
    }
    /// <summary>Returns a smooth Hermite interpolation between 0f and 1f when x is in [a, b]</summary>
    /// <param name="a">The minimum range of the x parameter</param>
    /// <param name="b">The maximum range of the x parameter</param>
    /// <param name="x">The value to be interpolated</param>
    /// <returns>Returns a value camped to the range [0, 1]</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float smoothstep(in float a, in float b, in float x) {
        var t = saturate((x - a) / (b - a));
        return t * t * (3f - (2f * t));
    }
    /// <summary>Returns the result of a componentwise step function where each component is 1f when x >= y and 0f otherwise</summary>
    /// <param name="y">Vector of values to be used as a threshold for returning 1</param>
    /// <param name="x">Vector of values to compare against threshold y</param>
    /// <returns>1 if the componentwise comparison x >= y is true, otherwise 0</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float step(in float y, in float x) {
        return select(0f, 1f, x >= y);
    }
    /// <summary>Given an incident vector i and a normal vector n, returns the reflection vector r = i - 2 * dot(i, n) * n</summary>
    /// <param name="i">Incident vector</param>
    /// <param name="n">Normal vector</param>
    /// <returns>Reflection vector</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float reflect(in float i, in float n) {
        return i - 2f * n * dot(i, n);
    }
    /// <summary>Returns the refraction vector given the incident vector i, the normal vector n and the refraction index eta</summary>
    /// <param name="i">Incident vector</param>
    /// <param name="n">Normal vector</param>
    /// <param name="eta">Index of refraction</param>
    /// <returns>Refraction vector</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float refract(in float i, in float n, in float eta) {
        float ni = dot(n, i);
        float k = 1f - eta * eta * (1f - ni * ni);
        return select(0f, eta * i - (eta * ni + sqrt(k)) * n, k < 0f);
    }
    /// <summary>Compute vector projection of a onto b</summary>
    /// <param name="a">Vector to project</param>
    /// <param name="b">Non-zero vector to project onto</param>
    /// <returns>Vector projection of a onto b</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float project(in float a, in float b) {
        return (dot(a, b) / dot(b, b)) * b;
    }
    /// <summary>Compute vector projection of a onto b. If result is not finite, then return the default value instead</summary>
    /// <param name="a">Vector to project</param>
    /// <param name="b">Non-zero vector to project onto</param>
    /// <param name="defaultValue">Default value to return if projection is not finite</param>
    /// <returns>Vector projection of a onto b or the default value</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float projectsafe(in float a, in float b, in float defaultValue = default) {
        var proj = project(a, b);
        return select(defaultValue, proj, all(isfinite(proj)));
    }
    /// <summary>Conditionally flips a vector n if two vectors i and ng are pointing in the same direction. Returns n if dot(i, ng) < 0, -n otherwise</summary>
    /// <param name="n">Vector to conditionally flip</param>
    /// <param name="i">First vector in direction comparison</param>
    /// <param name="ng">Second vector in direction comparison</param>
    /// <returns>-n if i and ng point in the same direction; otherwise return n unchanged</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float faceforward(in float n, in float i, in float ng) {
        return select(n, -n, dot(ng, i) >= 0f);
    }
    /// <summary>Returns the componentwise sine and cosine of the input float2 vector x through the out parameters s and c</summary>
    /// <param name="x">Input vector containing angles in radians</param>
    /// <param name="s">Output vector containing the componentwise sine of the input</param>
    /// <param name="c">Output vector containing the componentwise cosine of the input</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void sincos(in float x, out float s, out float c) {
        (s, c) = MathF.SinCos(x);
    }
    /// <summary>Returns the result of converting a float value value from degrees to radians</summary>
    /// <param name="x">Vector containing angles in degrees</param>
    /// <returns>Vector containing angles converted to radians</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float radians(in float x) {
        return x * (PI / 180f);
    }
    /// <summary>Returns the result of converting a float value value from radians to degrees</summary>
    /// <param name="x">Vector containing angles in radians</param>
    /// <returns>Vector containing angles converted to degrees</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float degrees(in float x) {
        return x * (180f / PI);
    }
    /// <summary>Returns b if c is true, a otherwise</summary>
    /// <param name="a">Value to use if c is false</param>
    /// <param name="b">Value to use if c is false</param>
    /// <param name="c">Bool value to choose between a and b</param>
    /// <returns>The selection between a and b according to bool c</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float select(in float a, in float b, in bool c) {
        return c ? b : a;
    }
    #endregion Component Math

}
