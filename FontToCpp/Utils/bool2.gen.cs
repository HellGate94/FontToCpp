//------------------------------------------------------------------------------
// <auto-generated>
// This code was generated by a tool
// Runtime Version: 1.0.0.0
//
// Changes to this file may cause incorrect behavior and will be lost if
// the code is regenerated
// </auto-generated>
//------------------------------------------------------------------------------
#nullable enable

using System;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace HellEngine.Mathematics;

/// <summary>Vector containing two bool values</summary>
[Serializable]
[StructLayout(LayoutKind.Sequential)]
public unsafe partial struct bool2 : IEquatable<bool2> {
    #region Members

    /// <summary>x Vector component</summary>
    [MarshalAs(UnmanagedType.U1)]
    public bool x;

    /// <summary>y Vector component</summary>
    [MarshalAs(UnmanagedType.U1)]
    public bool y;

    #endregion Members

    #region Index Accessor

    /// <summary>Access the bool at index</summary>
    public bool this[int index] {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get {
#if VALIDATION_CHECKS
            if (index >= 2) {
                throw new IndexOutOfRangeException("Index must be between [0..1]");
            }
#endif
            fixed (bool2* array = &this) { return ((bool*)array)[index]; }
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set {
#if VALIDATION_CHECKS
            if (index >= 2) {
                throw new IndexOutOfRangeException("Index must be between [0..1]");
            }
#endif
            fixed (bool* array = &x) { array[index] = value; }
        }
    }

    #endregion Index Accessor

    #region Static Fields

    /// <summary>bool2 zero value</summary>
    public static readonly bool2 zero = new bool2(false, false);

    /// <summary>bool2 one value</summary>
    public static readonly bool2 one = new bool2(true, true);

    /// <summary>bool2 unit x value</summary>
    public static readonly bool2 unitX = new bool2(true, false);

    /// <summary>bool2 unit y value</summary>
    public static readonly bool2 unitY = new bool2(false, true);

    #endregion Static Fields

    #region Constructors

    /// <summary>Creates a new bool2</summary>
    /// <param name="x">Value of x component</param>
    /// <param name="y">Value of y component</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool2(bool x, bool y) {
        this.x = x;
        this.y = y;
    }

    /// <summary>Creates a new bool2</summary>
    /// <param name="xy">Value of xy components</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool2(bool2 xy) {
        this.x = xy.x;
        this.y = xy.y;
    }

    #endregion Constructors

    #region Conversion

    /// <summary>Creates a bool2 vector from a bool value</summary>
    /// <param name="v">Component values. Converted if necessary</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool2(bool v) {
        this.x = v;
        this.y = v;
    }

    /// <summary>Converts a bool value to a bool2 vector</summary>
    /// <param name="v">Value to convert</param>
    /// <returns>Converted value</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static implicit operator bool2(bool v) => new bool2(v);

    #endregion Conversion

    #region Operators

    /// <summary>Componentwise negation operation on a bool2 vector</summary>
    /// <param name="value">Value for componentwise negation</param>
    /// <returns>Componentwise negation bool2 result</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool2 operator !(bool2 value) {
        return new bool2(!value.x, !value.y);
    }

    /// <summary>Componentwise bitwise and operation on two bool2 vectors</summary>
    /// <param name="left">Left hand side bool2 vector for bitwise and</param>
    /// <param name="right">Right hand side bool2 vector for bitwise and</param>
    /// <returns>Componentwise bitwise and result</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool2 operator &(in bool2 left, in bool2 right) {
        return new bool2(left.x & right.x, left.y & right.y);
    }

    /// <summary>Componentwise bitwise and operation on a bool2 vector and a bool value</summary>
    /// <param name="left">Left hand side bool2 vector for bitwise and</param>
    /// <param name="right">Right hand side bool value for bitwise and</param>
    /// <returns>Componentwise bitwise and result</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool2 operator &(in bool2 left, in bool right) {
        return new bool2(left.x & right, left.y & right);
    }

    /// <summary>Componentwise bitwise and operation on a bool value and a bool2 vector</summary>
    /// <param name="left">Left hand side bool value for bitwise and</param>
    /// <param name="right">Right hand side bool2 vector for bitwise and</param>
    /// <returns>Componentwise bitwise and result</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool2 operator &(in bool left, in bool2 right) {
        return new bool2(left & right.x, left & right.y);
    }

    /// <summary>Componentwise bitwise or operation on two bool2 vectors</summary>
    /// <param name="left">Left hand side bool2 vector for bitwise or</param>
    /// <param name="right">Right hand side bool2 vector for bitwise or</param>
    /// <returns>Componentwise bitwise or result</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool2 operator |(in bool2 left, in bool2 right) {
        return new bool2(left.x | right.x, left.y | right.y);
    }

    /// <summary>Componentwise bitwise or operation on a bool2 vector and a bool value</summary>
    /// <param name="left">Left hand side bool2 vector for bitwise or</param>
    /// <param name="right">Right hand side bool value for bitwise or</param>
    /// <returns>Componentwise bitwise or result</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool2 operator |(in bool2 left, in bool right) {
        return new bool2(left.x | right, left.y | right);
    }

    /// <summary>Componentwise bitwise or operation on a bool value and a bool2 vector</summary>
    /// <param name="left">Left hand side bool value for bitwise or</param>
    /// <param name="right">Right hand side bool2 vector for bitwise or</param>
    /// <returns>Componentwise bitwise or result</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool2 operator |(in bool left, in bool2 right) {
        return new bool2(left | right.x, left | right.y);
    }

    /// <summary>Componentwise bitwise exclusive or operation on two bool2 vectors</summary>
    /// <param name="left">Left hand side bool2 vector for bitwise exclusive or</param>
    /// <param name="right">Right hand side bool2 vector for bitwise exclusive or</param>
    /// <returns>Componentwise bitwise exclusive or result</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool2 operator ^(in bool2 left, in bool2 right) {
        return new bool2(left.x ^ right.x, left.y ^ right.y);
    }

    /// <summary>Componentwise bitwise exclusive or operation on a bool2 vector and a bool value</summary>
    /// <param name="left">Left hand side bool2 vector for bitwise exclusive or</param>
    /// <param name="right">Right hand side bool value for bitwise exclusive or</param>
    /// <returns>Componentwise bitwise exclusive or result</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool2 operator ^(in bool2 left, in bool right) {
        return new bool2(left.x ^ right, left.y ^ right);
    }

    /// <summary>Componentwise bitwise exclusive or operation on a bool value and a bool2 vector</summary>
    /// <param name="left">Left hand side bool value for bitwise exclusive or</param>
    /// <param name="right">Right hand side bool2 vector for bitwise exclusive or</param>
    /// <returns>Componentwise bitwise exclusive or result</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool2 operator ^(in bool left, in bool2 right) {
        return new bool2(left ^ right.x, left ^ right.y);
    }

    #endregion Operators

    #region Swizzle

    /// <summary>Swizzles the bool2 vector</summary>
    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
    public bool2 xx {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => new bool2(x, x);
    }

    /// <summary>Swizzles the bool2 vector</summary>
    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
    public bool2 xy {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => new bool2(x, y);
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set {
            this.x = value.x;
            this.y = value.y;
        }
    }

    /// <summary>Swizzles the bool2 vector</summary>
    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
    public bool2 yx {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => new bool2(y, x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set {
            this.y = value.x;
            this.x = value.y;
        }
    }

    /// <summary>Swizzles the bool2 vector</summary>
    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
    public bool2 yy {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => new bool2(y, y);
    }

    #endregion Swizzle

    #region Equals

    /// <inheritdoc/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public override int GetHashCode() {
        return HashCode.Combine(x, y);
    }

    /// <inheritdoc/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool Equals(bool2 other) {
        return x == other.x && y == other.y;
    }

    /// <inheritdoc/>
    public override bool Equals([NotNullWhen(true)] object? obj) => obj is bool2 value && Equals(value);

    #endregion Equals

    #region ToString

    /// <summary>Returns a string that represents the current values</summary>
    /// <returns>The values of the current instance with the specified format</returns>
    public override string ToString() {
        return string.Format("bool2({0} {1})", x, y);
    }

    #endregion ToString
}

public static unsafe partial class math {
    #region Component Math

    /// <summary>Creates a bitmask representation of a bool2 vector encoding each value as one bit</summary>
    /// <remarks>Stored in least significant bit (LSB) order (lowest to highest)</remarks>
    /// <param name="x">Input for the bitmask</param>
    /// <returns>Bitmask representation of a bool2 vector</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static int bitmask(in bool2 x) {
        int mask = 0;
        if (x.x) mask |= 1;
        if (x.y) mask |= 2;
        return mask;
    }
    /// <summary>Returns true if any component of the input bool2 vector is true, false otherwise</summary>
    /// <param name="x">Vector of values to compare</param>
    /// <returns>True if any the components of x are true, false otherwise</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool any(in bool2 x) {
        return x.x | x.y;
    }
    /// <summary>Returns true if all components of the input bool2 vector is true, false otherwise</summary>
    /// <param name="x">Vector of values to compare</param>
    /// <returns>True if all the components of x are true, false otherwise</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool all(in bool2 x) {
        return x.x & x.y;
    }
    /// <summary>Returns b if c is true, a otherwise</summary>
    /// <param name="a">Value to use if c is false</param>
    /// <param name="b">Value to use if c is false</param>
    /// <param name="c">Bool value to choose between a and b</param>
    /// <returns>The selection between a and b according to bool c</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool2 select(in bool2 a, in bool2 b, in bool c) {
        return c ? b : a;
    }
    /// <summary>Returns a componentwise selection between two bool2 vectors a and b based on a bool2 vector selection mask c. Per component, the component from b is selected when c is true, otherwise the component from a is selected</summary>
    /// <param name="a">Value to use if c is false</param>
    /// <param name="b">Value to use if c is false</param>
    /// <param name="c">Selection mask to choose between a and b</param>
    /// <returns>The componentwise selection between a and b according to selection mask c</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool2 select(in bool2 a, in bool2 b, in bool2 c) {
        return new bool2(math.select(a.x, b.x, c.x), math.select(a.y, b.y, c.y));
    }
    #endregion Component Math

}
